// 벡터
// 메모리 상 서로 이웃하도록 값을 넣는, 단일 데이터 구조 안에 하나 이상의 값을 저장할 수 있는 collection.
// 같은 타입의 값만 저장할 수 있다.

fn main() {

    // 벡터는 generic으로 구현되어 있기 때문에, 특정 타입의 값을 저장할 때 타입을 <> 안에 명시해줘야 한다.
    let v1: Vec<i32> = Vec::new();

    // 만약 벡터의 타입을 명시적으로 유추할 수 있는 경우에는 지정하지 않아도 된다.
    // vec! 매크로는 준 값으로 새로운 벡터를 생성한다.
    let v2 = vec![1, 2, 3];


    // 벡터 갱신하기 - 벡터에 넣는 값을 통해서 타입을 유추한다.
    let mut v3 = Vec::new();
    v3.push(5);
    v3.push(6);
    v3.push(7);

    // 벡터를 드롭하면 벡터 안의 모든 요소들 또한 같이 드롭된다.
    {
        let v = vec![1, 2, 3, 4, 5];
    }

    // 벡터 읽기
    let v4 = vec![1, 2, 3, 4, 5];

    // 아래와 같이 두 가지 방법으로 접근할 수 있다.
    // 벡터가 가지고 있지 않은 인덱스 값을 사용하고자 했을 때 프로그램이 어떻게 동작하게 할 것인지 두 가지 방법을 활용할 수 있다.
    let third: &i32 = &v4[2];
    let third: Option<&i32> = v4.get(2);

    // let does_not_exist = &v[100]; -> 인덱싱을 사용하는 경우, 인덱스가 존재하지 않으면 panic!을 일으킨다.
    let does_not_exist = v4.get(100); // -> 패닉 없이 None이 리턴된다. 
    

    // 유효하지 않은 참조자
    // 프로그램이 유효한 참조자를 가지고 있는 상태에서 벡터를 갱신하려고 하면 에러가 발생할 수 있다.
    let mut v5 = vec![1, 2, 3, 4, 5];

    let first = &v5[0];

    // 새로운 요소를 벡터 끝에 추가하면 새로 메모리를 할당하여 예전 요소를 새 공간에 복사하는 작업이 필요할 수 있는데,
    // 벡터가 모든 요소들을 붙여서 저장할 공간이 충분 치 않은 환경에서 에러가 발생할 수 있다.
    // 첫 번째 요소에 대한 참조자는 할당이 해제된 메모리를 가리키게 되므로, borrow rule에 어긋나게 된다.
    v5.push(6); // 벡터 끝에 새로운 요소를 추가한다.
    v5.pop(); // 벡터의 끝 요소를 반환하고 지운다.

    // 벡터의 iter
    let v6: Vec<i32> = vec![100, 32, 57];

    // 단순 조회만 하고싶은 경우
    for i in &v6 {
        println!("{}", i);
    }

    // 요소를 변형시키고 싶은 경우
    let mut v6: Vec<i32> = vec![100, 32, 57];

    for i in &mut v6 {
        *i += 50; // 가변 참조자가 참고하고 있는 값을 바꾸기 위해 역참조 연산자 (*)를 사용해 값을 얻어와야 한다.
    }

    // enum을 사용하여 벡터 안에 여러 타입 저장하기
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];

    // 러스트는 컴파일 타임에 벡터 내 저장될 타입을 알아야 얼만큼의 힙 메모리가 필요한지 알 수 있다.
    // 만약 런타임에 벡터에 저장할 타입의 모든 경우를 알지 못한다면 열거형을 이용한 방식 대신 trait을 사용할 수 있다.
}